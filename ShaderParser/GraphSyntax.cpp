// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma warning(disable:4800) // 'int': forcing value to bool 'true' or 'false' (performance warning))

#include "GraphSyntax.h"
#include "ShaderPatcher.h"
#include "AntlrHelper.h"
#include "Grammar/GraphSyntaxLexer.h"
#include "Grammar/GraphSyntaxParser.h"
#include "Grammar/GraphSyntaxEval.h"
#include "../Utility/FunctionUtils.h"
#include <unordered_map>
#include <stack>


namespace ShaderPatcher
{
	using namespace ShaderSourceParser::AntlrHelper;

	class GraphSyntaxParserRig
    {
    public:
        GraphSyntaxParserRig(StringSection<char> sourceCode);
        ~GraphSyntaxParserRig();

        GraphSyntaxParserRig(const GraphSyntaxParserRig&) = delete;
        GraphSyntaxParserRig& operator=(const GraphSyntaxParserRig&) = delete;
    private:
        class Pimpl;
        std::unique_ptr<Pimpl> _pimpl;

		ANTLR3_BASE_TREE* BuildAST();
    };

    class GraphSyntaxParserRig::Pimpl
    {
    public:
        AntlrPtr<struct ANTLR3_INPUT_STREAM_struct>				_inputStream;
        AntlrPtr<struct ANTLR3_COMMON_TOKEN_STREAM_struct>		_tokenStream;
		AntlrPtr<struct GraphSyntaxLexer_Ctx_struct>			_lxr;
        AntlrPtr<struct GraphSyntaxParser_Ctx_struct>			_psr;

		AntlrPtr<struct ANTLR3_COMMON_TREE_NODE_STREAM_struct>	_nodes;
		AntlrPtr<struct GraphSyntaxEval_Ctx_struct>				_evalTree;

		ExceptionSet _exceptionSet;
    };

	class WorkingNodeGraph
	{
	public:
		NodeGraph _graph;

		struct Connector { uint32_t nodeId; std::string _name; };
		std::vector<Connector> _connectors;
		std::vector<std::string> _literalConnectors;
		std::unordered_map<std::string, uint32_t> _nodeNameMapping;
		std::stack<uint32_t> _activeNodes;
	};

	ANTLR3_BASE_TREE* GraphSyntaxParserRig::BuildAST()
    {
        auto* parser = _pimpl->_psr.get();

        // Antlr stuff is in 'C' -- so we have to drop back to a C way of doing things
        // these globals means we can only do a single parse at a time.
        auto* oldHandler = g_ShaderParserExceptionHandler;
        auto* oldHandlerUserData = g_ShaderParserExceptionHandlerUserData;
        auto cleanup = AutoCleanup(
            [oldHandler, oldHandlerUserData]() 
            {
                g_ShaderParserExceptionHandler = oldHandler;
                g_ShaderParserExceptionHandlerUserData = oldHandlerUserData;
            });

        _pimpl->_exceptionSet._errors.clear();
        g_ShaderParserExceptionHandlerUserData = &_pimpl->_exceptionSet;
        g_ShaderParserExceptionHandler = (ExceptionHandler*)&ExceptionSet::HandleException;

        auto result = parser->entrypoint(parser).tree;
        if (!_pimpl->_exceptionSet._errors.empty())
            Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(_pimpl->_exceptionSet._errors)));

		return result;
    }

    GraphSyntaxParserRig::GraphSyntaxParserRig(StringSection<char> sourceCode)
    {
        _pimpl = std::make_unique<Pimpl>();

        _pimpl->_inputStream = antlr3StringStreamNew(
            (ANTLR3_UINT8*)sourceCode.begin(), ANTLR3_ENC_8BIT, 
            (unsigned)sourceCode.size(), (ANTLR3_UINT8*)"InputStream");
        if (!_pimpl->_inputStream)
			Throw(::Exceptions::BasicLabel("Unable to create the input stream due to malloc() failure\n"));

		_pimpl->_lxr = GraphSyntaxLexerNew(_pimpl->_inputStream);	    // CLexerNew is generated by ANTLR
		if (!_pimpl->_lxr)
			Throw(::Exceptions::BasicLabel("Unable to create the lexer due to malloc() failure\n"));

		_pimpl->_tokenStream = antlr3CommonTokenStreamSourceNew( ANTLR3_SIZE_HINT, TOKENSOURCE(_pimpl->_lxr));
		if (!_pimpl->_tokenStream)
			Throw(::Exceptions::BasicLabel("Out of memory trying to allocate token stream\n"));

		_pimpl->_psr = GraphSyntaxParserNew(_pimpl->_tokenStream);  // CParserNew is generated by ANTLR3
		if (!_pimpl->_psr)
			Throw(::Exceptions::BasicLabel("Out of memory trying to allocate parser\n"));

		{
			auto* _ast = BuildAST();

			_pimpl->_nodes = antlr3CommonTreeNodeStreamNewTree(_ast, ANTLR3_SIZE_HINT);
			_pimpl->_evalTree = GraphSyntaxEvalNew(_pimpl->_nodes);

			WorkingNodeGraph ng;
			_pimpl->_evalTree->_userData = &ng;

			auto* oldHandler = g_ShaderParserExceptionHandler;
			auto* oldHandlerUserData = g_ShaderParserExceptionHandlerUserData;
			auto cleanup = AutoCleanup(
				[oldHandler, oldHandlerUserData]() 
				{
					g_ShaderParserExceptionHandler = oldHandler;
					g_ShaderParserExceptionHandlerUserData = oldHandlerUserData;
				});

			ExceptionSet exceptionSet;
			g_ShaderParserExceptionHandlerUserData = &exceptionSet;
			g_ShaderParserExceptionHandler = (ExceptionHandler*)&ExceptionSet::HandleException;

			_pimpl->_evalTree->entrypoint(_pimpl->_evalTree);

			if (!exceptionSet._errors.empty())
				Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionSet._errors)));
		}
    }

    GraphSyntaxParserRig::~GraphSyntaxParserRig() {}

///////////////////////////////////////////////////////////////////////////////////////////////////

	void ReadGraphSyntax(StringSection<char> input)
	{
		// Parse the input graph syntax, and build a node graph
		// with ShaderPatcher::Node. Then run GenerateStructureForTechniqueConfig to generate the final output
		GraphSyntaxParserRig parserRig(input);
		(void)parserRig;
	}

}

typedef unsigned NodeId;
typedef unsigned ConnectorId;
typedef unsigned ConnectionId;

extern "C" NodeId Node_Register(const void* ctx, const char archiveName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	NodeId nextId = (NodeId)ng->_graph.GetNodes().size();
	ShaderPatcher::Node newNode(archiveName, nextId, ShaderPatcher::Node::Type::Procedure);
	ng->_graph.Add(std::move(newNode));
	return nextId;
}

extern "C" ConnectorId Connector_Register(const void* ctx, NodeId node, const char connectorName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	ConnectorId nextId = (ConnectorId)ng->_connectors.size();
	ng->_connectors.push_back({node, connectorName});
	return nextId;
}

extern "C" ConnectorId LiteralConnector_Register(const void* ctx, const char literal[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	ConnectorId nextId = 0xf0000000u | (ConnectorId)ng->_literalConnectors.size();
	ng->_literalConnectors.push_back(literal);
	return nextId;
}

extern "C" ConnectionId Connection_Register(const void* ctx, ConnectorId left, ConnectorId right)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	if (left >= ng->_connectors.size())
		return ~0u;

	if (right & 0xf0000000u) {
		if ((right & ~0xf0000000u) >= ng->_literalConnectors.size())
			return ~0u;

		ShaderPatcher::ConstantConnection connection(
			ng->_connectors[left].nodeId, ng->_connectors[left]._name,
			ng->_literalConnectors[right & ~0xf0000000u]);
		ng->_graph.Add(std::move(connection));
	} else {
		if (right >= ng->_connectors.size())
			return ~0u;

		ShaderPatcher::NodeConnection connection(
			ng->_connectors[left].nodeId, ng->_connectors[right].nodeId,
			ng->_connectors[left]._name, ng->_connectors[right]._name,
			std::string());
		ng->_graph.Add(std::move(connection));
	}

	return ~0u;
}

extern "C" void Node_Name(const void* ctx, NodeId id, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_nodeNameMapping.insert({name, id});
}

extern "C" NodeId Node_Find(const void* ctx, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	auto i = ng->_nodeNameMapping.find(std::string(name));
	if (i != ng->_nodeNameMapping.end())
		return i->second;
	return ~0u;
}

extern "C" void Node_Push(const void* ctx, NodeId id)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeNodes.push(id);
}

extern "C" void Node_Pop(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeNodes.pop();
}

extern "C" NodeId Node_GetActive(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	if (ng->_activeNodes.empty())
		return ~0u;
	return ng->_activeNodes.top();
}

